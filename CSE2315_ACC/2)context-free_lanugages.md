# Context-free Languages

---

# 1. Grammars

## Context-Free Grammars (CFG)
In the last chapter we had a look at FSM and Regex, which are two (but equivalent) ways of describing languages.<br>
CFG is a more powerful method of describing languages.

### What is CFG?
Example:<br>
E -> E + T | T<br>
T -> T x F | F <br>
F -> (E) | a<br>

- Terminal and Non-terminal symbols
  - Non-terminal symbols: symbols that only appear on the right hand side
    - E, T, and F in the example above
  - Terminal symbols: symbols that appear on the left hand side
    - +, x, (, ), a


- All CFG's have:
  - Variables (non terminals)
  - Terminals (symbols from alphabet)
  - Rules (productions, e.g. E ::= E + T)
  - Start variable (often s; assume the first rule uses start symbol)


- Derivation of String from a CFG
  - Start with the start variable
  - Repeat until we only have terminals
  - Example: 
    - E => E+T => T+T => F+T => a+T => ... a+(axa)
    - Equivalent to: E *=> a+(E) *=> a+(T) *=> a+(axa)
  - Types of derivation:
    - Left-most derivation: always choose leftmost variable and convert to terminal first
    - Right-most derivation: rightmost variable first
    - They correspond to each other (one-to-one relation)
    - Other types also exist


- Parse Tree
  - There might be many was to derive a string using the CFG.
  - We might not use leftmost or rightmost derivation but still get a string that is recognised.
  - Regardless of the order of the rules used, the result string is always the same.
  - The parse tree abstracts away the actual order in which the rules are used. It only remembers which rules were used.


### Formal definition of CFG
> G = (V, Σ, R, S)
> - V = the set of variables (i.e. non-terminals)
> - Σ = the set of terminals 
> - R = the set of rules
> - S = start variable (S ε V)

note that V intersection Σ = {}

> The Language of a grammar is:<br>
> {w | w ε Σ* and S* => w}


> A "context-free language" is a language generated by a context free grammar.

- Example 1:
  - S -> (S) | SS | ε
  - Language = { ε, (), ()(), (()()), ((()()))()(()()), ... }
- Example 2: 
  - {0^n 1^n | n >= 0}
  - S -> ε
  - S -> OS1
  - Language = { ε, 01, 0011, 000111, ... }


### Designing CFG's
Let's consider an example. We have a language {w | w ε {0,1}* and the number of 0's equal the number of 1's}.<br>
Design the CFG for this language.

- CFG 1:
  - S -> 0A | 1B | ε
  - A -> 1S | 0AA | ε
  - B -> 0S | 1BB | ε
  - Note that here we consider:
    - S as the string with equal number of 0's and 1's,
    - A as the string with one more 0 than 1,
    - B as the string with one more 1 than 0.


- CFG 2:
  - S -> SAB | ε
  - A -> 0S1 | ε
  - B -> 1S0 | ε
  - Note that S = Sx | ε = x*


When constructing CFG for a CFL, we can use these strategies:
- Divide the CFL into simpler CFLs as many CFLs are the union of simpler CFLs.
- Create the DFA first and construct the CFG.
  - Make a variable for each state in the DFA
  - Add the rule Ri -> aRj to the CFG if δ(qi, a) = qj is a transition in the DFA
  - Add the rule Ri -> ε if qi is an accept state of the DFA
  - Make R0 the start variable of the grammar, where q0 is the start state of the machine
- If the string contains two substrings that are "linked" in some way, use the from R -> uRv


## Different kinds of CFL

### Ambiguity
Ambiguous Strings
- Strings with more than one parse trees (such as a+a*a)
- Fundamentally different ways to derive a string

Ambiguous Grammar
> A grammar is ambiguous if some string can be derived in more than one way.


- An ambiguous grammar can also have an equivalent unambiguous grammar.
- Ambiguous grammars can be easy to understand, but unambiguous grammars are preferred by programs and compilers.
- Some CFLs can only be generated by ambiguous grammars (called inherently ambiguous)


### Language onions
A language is subset of the language that comes below it.
- Regular languages (FSM, Regex)
- LL(k) languages (Predictive Parser)
- LR(k) languages (Deterministic Pushdown Automaton)
- Unambiguous languages
- Context-Free languages (Nondeterministic Pushdown Automaton)
- Decidable languagues (TM will always halt)
- Turing recognisable languages (TM will halt if "yes", but may loop if "no")
- All languages


## Chomsky Normal Form
> A grammar is in Chomsky normal form iff every rule in the grammar has the form:
> - A -> BC (exactly two variables; cannot be the starting variable S), or;
> - A -> a (or a terminal symbol; not epsilon), or;
> - S -> ε (starting variable is an epsilon)

For every CFG, there is an equivalent Chomsky normal form.

### Converting CFG to its Chomsky normal form
1. Make sure start symbol does not appear on righthand side
2. Remove rules like A -> ε
3. Get rid of all unit rules A -> B
4. Get rid of rules with more than 2 symbols on righhand side (both variables and terminals)
5. Make sure it follows the A->BC and A->a form.


## CFL closure
### Union
CFL is closed under union
- S1 -> ~
- S2 -> ~
- S -> S1|S2

### Concatenation
CFL is closed under concatenation
- S -> S1S2

### Intersection
CFL is not closed under intersection
- L1 = {0^i 1^i 2^x}
- L2 = {0^y 1^n 2^n}
- L1 intersect L2 = {0^m 1^m 2^m} -> this is not a CFL.

### Complement
CFL is not closed under complement
- A intersect B = (A^C U B^C)^C (DeMorgan's law)
- Assume closed under complement
- then right-hand side is closed
- then left-hand side is a CFL
- contradiction


# 2. PushDown Automata (PDA's)
A pushdown automaton has a stack in addition to the states, which acts as a memory.

The input string is the same as that in an FSM (it cannot back up)

The stack:
- Operations
  - Read + pop (or ignore)
  - Push (or ignore)
- Stack alphabet Γ

State transitions:
- may depend on stack top
- may push onto the stack
- are non-deterministic

A PDA notation looks like below:<br>
```
   a, b -> c  
O -----------> O
```
where:
- a is the input symbol (may be ε).
- b is the symbol on the top of the stack.
  - This symbol is popped. If the top of the stack does not match this symbol, then this path is not taken.
  - ε means the stack is neither read nor popped.
- c is the symbol that is being pushed onto the stack.
  - ε means nothing is pushed.

String is accepted if the string:
- begins in the start state
- ends in an accept state
- consumes all the input symbols (can leave symbols on the stack)
- there is a path through the finite state control


## Formal definition of PDA
> M = (Q, Σ, Γ, δ, q0, F)
> - Q = set of states
> - Σ = input alphabet
>   - Σε = Σ U {ε}
>   - Γε = Γ U {ε}
> - Γ = stack alphabet
> - δ = Q x Σε x Γε -> P(Q x Γε) (power set)
> - q0 = starting state (q0 ε Q)
> - F = accepting state (F is a subset of Q)


## Equivalence with CFG
All PDA's have equivalent CFG's and vice versa.

> A language is context-free iff some pushdown automaton recognises it.

We are proving this in two steps:
1. Given a CFG, show how to construct a pushdown automaton that describes it
2. Given a pushdown automaton, show how to construct a context-free grammar that recognises the same strings

### Part 1
Given: a grammar:
```
S -> BS | A
A -> 0A | ε
B -> BB1 | 2
```
find an equivalent PDA.

The transition functions are constructed by taking the steps below:
- Consider a derivation (left-most)
- Take all the terminals to the input, until a variable is encountered.
- From that point, put everything on the stack with the top being the left-most variable.
- At each step, expand left-most variable
  - match stack-top to a rule
  - pop stack
  - push right-hand side of rule onto stack
  - Note that this is equivalent to adding an edge to the PDA
    - for rule A -> BCD,
      - input is ε because it is not advanced
      - top is A because this is being popped and evaluated
      - push is BCD because this is being pushed to the stack
        - However, we cannot push multiple symbols at once in PDA
        - Instead, separate them to three edges
          - ε, A -> D
          - ε, ε -> C
          - ε, ε -> B
    - which rule to use does not matter because PDA's are non-deterministic
- If it is a terminal on the top of the stack, match it (i.e. pop it and advance input)
  - 0, 0 -> ε
  - 1, 1 -> ε
  - 2, 2 -> ε
  - etc for all x ε Σ

In conclusion,
- Create a starting state
- Add a new state and connect it from the starting state with edge ε, ε -> $
- Add a new state and connect it from the previous state with edge ε, ε -> S
- Add a loop for the state with all the rules being used for derivation
- Add an accepting state and connect it from the pervious state with edge ε, $ -> ε

### Part 2
Given: a PDA

Build a CFG from it.

Steps
- First simplify the PDA
  - Connect all the accepting states to a new state (q_end) with edge ε, ε -> ε
    - Change them to rejecting state
  - The PDA empties its stack before accepting (in this case), so:
    - create a new starting state and connect to the prev starting state with edge ε, ε -> $
    - create a new accepting state and connect from q_end with edge ε, $ -> ε
  - Each transition either pushes or pops, but does not do both
    - so a, X -> Y is split into two edges: a, X -> ε and ε, ε -> Y.
    - for the case of a, ε -> ε, replace with α, ε -> Ζ and α, Ζ -> ε. Z is the dummy symbol which is added to the stack alphabet.
- Create a variable for every pair of states.
  - The starting variable will be the variable created by the starting and accepting states
- For each p, q, r, s ε Q in the PDA, such that δ(p, a, ε) contains (r, t), and δ(s, b, t) contains (q, ε),
  - this means that [in state q, with input a, and stack ε: go to state r and push t] and [in state s, with input b, and stack t: go to state q and push nothing]
  - then add this rule to the CFG: A_pq -> a A_rs b

```
If we have a way from states p to q without touching the stack:
   a, ε -> t                      b, t -> ε
p ------------> r --- ... ---> s ------------> q

then we have the following rule:
A_pq -> a A_rs b
```
```
If we have a way to get from states p to r without touching the stack:
    A_pr
p --------> r

and have a way to get from r to q without touching the stack:
    A_rq
r --------> q

then we have a new way to get from p to q without touching the stack:
A_pq -> A_pr A_rq
```
```
There is a trivial way to get from state p to itself without touching the stack;
so add this for every state p:
A_pp -> ε
```
```
If the PDA accepts some string
then there is a way to go from q0 to q_accept
that does not touch the stack.

The grammar we seek should generate exactly these strings.

Our start variable is A_q0q_accept.
```